原文：
https://blog.csdn.net/qq_33336155/article/details/53859200
https://blog.csdn.net/qq_33336155/article/details/53859206
https://blog.csdn.net/qq_33336155/article/details/53859214

知识点：
# API 应用程序接口
# SDK  软件开发包
# GDI 图像设备接口
# 对应于unsigned long 的数据类型为DWORD
# 匈牙利命名 全局窗口句柄-g_hWnd (属性 类型 描述)
# 设备句柄 HDC
# 位图句柄 HBITMAP
# 典型的Windows窗口程序的流程为注册窗口类->创建窗口->显示窗口->更新窗口->消息循环 
# 菜单编辑器中，如果要设置某个项为分隔线，那么这个项的Separator属性为true  
# 在Windows消息机制中，菜单消息类型是 WM_COMMAND  
# 在Windows编程中，代表键盘的"↑"键的虚拟键值是 VK_UP
# 在Windows编程中，响应键盘按键按下消息的Windows消息是 WM_KEYDOWN 
# 在Windows编程中，按下键盘的"A"键后，返回的Windows消息是 WM_KEYDOWN
# 在Windows编程中，按下鼠标左键产生的Windows消息是 WM_LBUTTONDOWN
# 在Windows编程中，标准鼠标的按键数是 3
# Windows编程中，定时器消息是 WM_TIMER
# GDI环境中，窗口的坐标系是 左上角为原点，x轴正方向为水平向右，y轴正方向为竖直向下  
# 设备环境DC的全称为 Device Contexts
# InvalidateRect的作用是 使一个矩行区域变为无效，从而可以重绘
# LineTo 不受画刷影响
# 要创建一个宋体字体，那么字体描述中lfFaceName属性设置为“宋体”
# 实现透明贴图（模板位图为单色的1位位图）位图和背景像素作异或操作->使用模板位图作与操作->原位图与背景作异或操作
# 在BitBlt函数中进行光栅化处理方式中，SRCPAINT 说明是要进行或运算
# 透明贴图的透明色可以是任意颜色，但不透明部分不应该包含该颜色
# 进程最常见和最理想的结束方式为 主线程的入口函数返回
# 线程正常结束的方式是 线程函数返回 
# 两个没有任何安全措施的线程同时对一个数作自增(++)运算，由于自增(++)不是原子操作，最后结果不一定是2 
# 能触发WaitForSingleObject返回的事件-特定的内核对象变为已通知状态
# 创建互斥体的函数为 CreateMutex
# SetWaitableTimer的参数lPeriod如果为正值，单位 毫秒(ms)
# 定义动态链接库时，模块定义文件确定函数f的导出顺序 f @1
# 动态链接库的显式链接的好处的是
	1 程序可以随时加载动态链接库
	2 显式链接的动态链接库的函数地址发生变化时，程序不需要重新编译
	3 动态链接库的载入语句可以出现在程序的任意位置
# C++语言的帮助库 MSDN
# 在MFC类库中，CWnd类的基类是 CObject
# CTime不是从CObject类派生的
# 在MFC中，最顶层的窗口一定属于CWnd类或其子类的实例
# 在MFC框架中，CButton类的基类是 CWnd   
# 在MFC编程中，如果要显示1个树型视图，那么适合选用的视图类 CTreeView
# 在MFC类库中，代表整个窗口的设备上下文的类是 CWindowDC
# 在MFC编程中，应用对象派生自类 CWinApp 
# 下列几个MFC类中，不属于应用和线程支持类的是（C）。  A. CWinThread B. CEvent C. CWnd D. CMuteX 
# 在由MFC AppWizzard生成的MFC程序中，后缀名为sln的文件表示 解决方案文件
# 下列哪个函数不是由CWinApp提供的函数？（C）A. Run B. InitInstance C. OnPaint D. OnIdle
# 在CWinApp类的关键函数中，负责消息循环的函数是 Run
# 在MFC编程中，资源的ID取值范围最小值为 1 
# 控件消息通知码的前缀 BN表示是按键消息 CB表示是组合框消息 EN表示是编辑控件消息 
# 标准的窗口消息其前缀是 WM
# MFC的消息机制中，最初的消息接收者是 主框架窗口
# 在MFC消息机制中，1个单文档视图应用程序的消息处理优先级顺序是 视图、文档、主框架、应用程序
# ON_MESSAGE 宏用于处理用户自定义消息
# 窗口截获消息，按照消息类型进行传递，由具体的对象处理
# 下列哪个MFC中的宏与消息映射无关？（A）A. DECLARE_DYNAMIC B. ON_CONTROL C. ON_COMMAND_RANGE D. ON_UPDATE_COMMAND_UI_RANGE
# 在MFC中，定义消息映射架构的基类是 CCmdTarget
# 在MFC中，标准消息宏ON_CONTROL参数中不包括 窗口句柄
# 在菜单资源编辑界面中，选择菜单属性Separator为true，则该菜单项 不能提供命令，只有1个分割线 
# 在菜单资源编辑界面中，要为菜单添加子菜单，需要设置的属性是 Popup
# 在响应菜单的消息时，消息类型应该是 命令（COMMAND）消息
# 菜单消息响应，在设置范围映射时，如果参数表中第1个消息ID值大于最后一个消息的值（不为0），则消息不能被响应
# 要获取1个菜单的子菜单，应该选用的函数是 GetSubMenu
# 关于快捷键的设置，如果1个快捷键同时对应两个消息ID，则只有前1个起作用，能够正常运行
# 工具栏可以同时显示文字和位图
# 在按钮的Prompt属性中添加“绘制椭圆\n椭圆”，则鼠标停留在此按钮上，窗口中显示为 状态栏显示“绘制椭圆”，鼠标提示“椭圆”
# 设置“剪切”按钮的文字提示的语句正确的是 m_wndToolBar.SetButtonText(4,"剪切")
# 使用AppWizzard创建MFC应用程序时，可以创建默认的状态栏 
# 标识符ID_SEPARATOR的含义是 没有任何字符串与这个状态栏单元关联
# 自定义状态栏中，改变状态栏文字的函数是 SetPaneText
# 自定义状态栏中，要获取状态栏的风格，使用的系统函数是 GetPaneInfo
# 在MFC类中，访问对话框的编辑框中的文本的函数是 GetDlgItemText
# MFC编程中，有模式对话框的创建函数是 DoModal
# 模式对话框创建的流程 加载资源->CreateDlgIndirect->OnInitDialog->UpdateData
# 在Windows操作系统中，最常见的系统错误提示对话框属于 模式对话框
# 关于对话框运行机制，下列说法错误的是（B）A. 对话框的初始化中，必须初始化父类对象 B. 在对话框的DoModal函数中，应该进行资源释放的操作 C. 有模式对话框中，直到对话框关闭后函数DoModal才返回 D. 对话框的OnInitDialog函数并没有消息映射体
# 下列关于对话框中数据交换 可以交换基本数据类型和一些特定的类类型的数据
# 在MFC编程中，从对话框中取得数据的系统函数是 DoDataExchange
# 下列哪1种功能没有被封装为通用对话框？（C）A. 颜色选择 B. 字体选择 C. 时间选择 D. 打印设置
# 关于颜色对话框，以下说法错误的是（C）A. 颜色对话框是模式对话框 B. 颜色对话框的DoModal函数能够返回1个选择的颜色值 C. 颜色对话框设定颜色后，程序需要调用窗口重绘消息来更新颜色 D. 颜色对话框可以自定义颜色
# 在创建了颜色对话框后，调用设定的颜色需要使用函数 GetColor
# 关于文件对话框的系统函数，以下说法正确的是（D）A. 文件对话框可以得到1个文件的数据 B. 文件对话框可以得到1个文件指针（FILE*）C. 文件对话框可以得到文件的句柄（后缀）D. 文件对话框可以得到文件名的字符串（CString）
# 如果要1个文件对话框只能显示文件夹中的bmp文件，则建立对话框时应该设置的参数是 lpszFilter
# 查找和替换对话框都是无模式的
# 关于查找和替换对话框，以下说法错误的是（B）。A. 查找和替换对话框可以使用同1个类来创建 B. 查找和替换对话框需要使用不同的类来创建 C. 查找对话框的bFindDialogOnly参数值为TRUE D. 替换对话框的bFindDialogOnly参数值为FALSE
# 在字体对话框函数中，获取字体大小的函数是 GetSize  
# 在MFC编程中，打印机硬件属于 CDC类
# 在MFC的打印对话框类中，函数GetToPage的作用是 获取打印范围的结束页
# 生成1个只具有确定和取消按钮的消息框，其参数为　MB_OKCANCEL
# 全局函数MessageBox可以在所有的MFC程序中被调用 
# 在窗口中添加一个仅仅用于显示文字提示的控件，这个控件的类为 CStatic
# 在MFC编程中，所有基于窗口的控件类的基类是 CWnd
# 窗口成为活动窗口的消息是 WM_ACTIVATE
# CTime 不属于标准控件类
# 在MFC编程中，可编辑文本框的控件类是 CEdit 
# MFC的资源编辑界面，如果1个单选按钮的Group属性被设置为“TRUE”，则说明 该单选按钮是1组单选按钮的第1个 
# 要设置某个单选按钮的状态，使用的函数是 SetCheck
# 默认情况下，所有的静态控件的ID都是相同的 
# 在编辑控件（CEdit）中设置属性Number为“TRUE”，则 编辑控件只接受数字的输入
# 下列函数中，哪1个函数不能对多行文本中的部分内容进行操作？（A）A. GetWindowText B. GetLine C. SetLine D. GetSel
# 要在列表框中添加字符串，可以使用的系统函数是 AddString
# 文件类中，实现串行化的函数是 Serialize
# 文档类包含一个链表，用于保存应用数据
# 视图类中在屏幕上绘制图形的函数为 OnDraw
# FAT32 NTFS FAT 文件系统属于Windows平台
# 可以用Windows句柄标识的有 窗口 文件 字体
# 系统可能向窗口发送WM_PAINT消息的情况：窗口最初创建时 窗口移动后部分区域由不可见变为可见 窗口大小改变后 滚动条滚动后
# 每个运行着的Windows程序都有对应的Windows实例句柄；1个Windows实例句柄可以对应多个窗口句柄 
# 在注册窗口类中，不需要进行的操作是 确定窗口大小 确定窗口标题
# PeekMessage立即返回；GetMessage将会等待消息到来 
# 动态菜单-函数CreatMenu用于建立空菜单；函数InsertMenu用于在菜单中插入1个菜单项
# Windows的鼠标消息-鼠标的按键消息种类可以从message中得到；鼠标的位置信息可以从lParam中得到 
# 能用于绘制直线的函数 LineTo、Polyline
# 能用于绘制直线的函数LineToPolyline
# 画笔的线型包括 实线  点划线  虚线
# 创建画刷的函数有：CreateHatchBrush CreateSolidBrush CreatePatternBrush
# 创建画刷的函数有：CreateHatchBrushCreateSolidBrushCreatePatternBrush位图文件包含那些部分A) 位图文件头（bitmap-file header）B) 位图信息头（bitmap-information header）C) 色彩表（color table）D) 定义位图的字节阵列
# 基于GUI的Windows程序的入口函数为：A) WinMain B) wWinMain
# 线程组成-线程的内核对象、线程堆栈
# 动态链接库的定义-A) 动态链接库可以使用模块定义文件指定导出哪些函数  B) 动态链接库在程序运行过程中动态载入 C) 动态链接库可以通过在函数名前使用关键字_declspec(dllexport)实现
# 关于动态链接库的导入，以下说法正确的是（AC）A) 使用隐式链接，应用程序需要编译 B) 使用显式链接，应用程序需要编译 C) 隐式链接的语句出现在程序的预处理语句部分 D) 显式链接的语句出现在程序的预处理语句部分
#  一个基本的Windows游戏程序结构包括：A) 初始化 B) 消息循环 C) 交互 D) 游戏对象的撤销
# MFC的优点-MFC封装了底层API，用户不需要直接与系统底层打交道；MFC提供了一系列的框架供开发者使用
# 下列哪些功能是由CObject提供的？（ABC）A)序列化 B)对象诊断输出 C)运行时类信息 D)消息映射

# MainFrm,CDocument和CView类之间的关系,
MainFrm为框架类，包含应用程序外框所包含部分。CView为视图类，用于显示数据的空白区域窗口。CDocument为文档类。
MFC提供了文档/视类结构，采用数据本身和显示分离的机制。其中文档类CDocument用于数据的存储和加载，视类CView用于数据的显示与修改。

# Dialog和 ModuelDialog不同用法
1）类型不同
MoudleDialog 模态对话框，属于垄断对话框，例如打开对话框，点击打开后不能再执行其他操作，会发出“嘟嘟嘟”的声音；
非模态对话框，属于非垄断对话框，利用查找对话框，点击查找同时可以执行其他操作；
即：非模态不垄断；模态垄断。
2）用法不同
CDialog::Create ：to create amodelessdialog box
CDialog::DoModal ：Call thismember function to invoke the modal dialog box andreturn the dialog-box resultwhen done

# windows消息系统由哪几部分构成?
3部分组成：
1.消息队列：操作系统负责为进程维护一个消息队列，程序运行时不断从该消息队列中获取消息、处理消息；
2.消息循环：应用程序通过消息循环不断获取消息、处理消息。
3.消息处理：消息循环负责将消息派发到相关的窗口上使用关联的窗口过程函数进行处理。

 

# 什么时候必须重写拷贝构造函数?
当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝。

# 什么是消息映射?
消息映射就是让程序员指定MFC类（有消息处理能力的类）处理某个消息。然后由程序员完成对该处理函数的编写，以实现消息处理功能。

# 如何定义和实现一个类的成员函数为回调函数?
所谓的回调函数，就是预先在系统的对函数进行注册，让系统知道这个函数的存在，以后，当某个事件发生时，再调用这个函数对事件进行响应。
定义一个类的成员函数时在该函数前加CALLBACK即将其定义为回调函数，函数的实现和普通成员函数没有区别

# MFC为何使用消息映射表而不用虚函数？
这个问题是windows开发面试中最经常问到得问题，也是很有深度的一个问题。
有两个帖子对该问题讨论的比较深刻：
http://topic.csdn.net/u/20090822/16/4cf5d189-0e5e-41ff-9ba3-c7eaf2f6da74.html
http://topic.csdn.net/u/20090316/22/8b067591-6a17-4970-b224-41ab589294b3.html
说法一：
虚函数实现占用内存较大
  侯捷在《深入浅出MFC》中说微软使用消息映射机制而不用虚函数，是因为虚函数空间代价的原因。在当前MFC2.0版本发布的时候是92年，pc的内存才几M。一个类的虚表的大小就是虚函数的个数*一个指针的大小。
  假设windows的通用消息有200个，那么CWnd类的虚表就有 200*4个byte = 800byte，CWnd类的所有派生类均copy了一份CWnd的虚表vtable，然后自己的虚函数往后加CWnd类的虚表的后头。
  （至于有人说CWnd类的派生类能共享CWnd的虚表，这个说法不靠谱。因为派生类自己的虚函数值加在基类的虚函数表项的最后的。如果CWnd派生了CWndChildA 和 CWndChildB，且两个孩子均有自己的虚函数，那么都往CWnd类的后面加，岂不是冲突了？）。
  也就是系统内所有的CWnd类的派生类都要承受 800byte的代价。假设有100个类派生自CWnd 那么代价就是800*100byte 也就是 80K。这在当时内存很紧张的情况下，已经是一种巨大的内存消耗了！这里需要注意一点：vtable是和类绑定在一起的，而不是和类对象（也叫类的实例）绑定在一起的，类的实例仅增加一个指向该向类的vtable的指针而已。也就是说，如果你有100个CWnd派生类，哪怕你生成了100000个派生类的实例，vtable占用的内存也是80K。
  看来在当时的环境看来，MFC没有采用虚函数，内存的确是一个考虑。
但是放在现在看，这点内存消耗确实微不足道的！也就是说，如果现在重新设计MFC的消息机制，如果不采用虚函数，并非因为虚函数的空间浪费问题。
结论：这个说法靠谱。
说法二：
  消息映射机制效率比虚函数效率高。
  因为那么多消息ID，如果找到其对应的消息处理函数，switch是不可少的！（可以hash？哦哦，的确可能，不过mfc里面可没这么做？mfc里面怎么做的我也不清楚）MFC中采用的是消息映射的机制，而没有用虚函数的机制，因为消息有很多，如果用虚函数机制，需要给每个消息定义一个虚函数，在分派消息时，程序需要逐一判断是哪一个消息，找到合适的分支后再调用相应的虚函数；而通常情况下，应用程序不需要响应太多的消息，消息映射方式只需要判断程序想要响应的这些消息即可，所以开销小。 
  也就是说，MFC采用了消息映射而没有采用虚函数，是从对消息的响应机制来考虑的。 消息映射，就可以仅实现自己感兴趣的消息，这样switch时就可以快一点。
  不过话又说回来，对一个非自己感兴趣的系统消息来了以后，就需要遍历消息网，层层的向基类查找直到找到对应的消息处理函数！这本身也很浪费时间！也许这种情况比较少见吧，否则的话，消息映射的消息响应时间并不比虚函数来的快！因为虚函数最多只需一次遍历，而且，如果可以采用hash技术，更快！
如果说，大多数消息都是系统的消息，那么消息映射的迭代查找消息函数的方式并不比虚函数的switch来的快！
PS：这里有一篇对比消息映射机制和虚函数机制效率的简单模拟实验 http://blog.csdn.net/hjsunj/archive/2008/01/10/2034314.aspx 
结论：该说法不靠谱！

说法三：
  为了未来的可扩展性。兼容新的系统级的消息。
  我不是很清楚MS设计消息映射的初衷，但是感觉它着眼点更侧重于增加新消息很容易，而不是节省内存。 
  如果我们使用虚函数机制实现，恐怕对于每个可能的消息我们都必须在基类中定义一个虚函数，而其首要的困难就是你无法猜测未来会出现什么消息，也无法确定需要定义什么样函数原型的虚函数。而使用消息映射，解决这个问题则相对容易，因为这将由未来的程序设计者决定他们的消息该如何处理。
  对于系统的新增消息，消息映射支持起来较方便。虚函数想要支持就需要改动基类添加虚函数。
  对于自定义的消息，无论消息映射和虚函数都可以很好的支持。
  那么虚函数方式如何支持自定义消息?自定义消息是不需要加到基类的。基类可以加个虚函数，OnMessage(xxx), 然后有自定义消息的类实现之，用switch转换成相应虚函数调用，不是自己的消息再传给基类。
结论：这个说法靠谱。

# sendMessage与postMessage区别？
不同点：sendMessage发送完毕以后需要等待处理完才返回；而postMessage发送消息后立即返回。
Do not post the WM_QUIT message usingPostMessage; use thePostQuitMessage function.
postMessage将消息放置到消息队列中，不等待线程处理消息就立即返回。
sendMessage发送指定的消息到窗口，并会调用窗口过程，直到窗口过程处理完毕后才返回。

# TCP的重发机制是怎么实现的？
1.滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少（已确认）、尚未确认的字节数、尚待发送的字节数；让接收方知道（已经确认收到的字节数）。
2.选择重传，用于对传输出错的序列进行重传。

# TCP和UDP的区别？
1）TCP面向连接（三次握手机制），通信前需要先建立连接；UDP面向无连接，通信前不需要建立连接；
2）TCP保障可靠传输（按序、无差错、不丢失、不重复）；UDP不保障可靠传输，使用最大努力交付；
3）TCP面向字节流的传输，UDP面向数据报的传输。

# TCP为什么不是两次连接？而是三次握手？
如果A与B两个进程通信，如果仅是两次连接。可能出现的一种情况就是：A发送完请报文以后，由于网络情况不好，出现了网络拥塞，即B延时很长时间后收到报文，即此时A将此报文认定为失效的报文。B收到报文后，会向A发起连接。此时两次握手完毕，B会认为已经建立了连接可以通信，B会一直等到A发送的连接请求，而A对失效的报文回复自然不会处理。依次会陷入B忙等的僵局，造成资源的浪费。

# connect方法会阻塞，请问有什么方法可以避免其长时间阻塞？
可以考虑采用异步传输机制，同步传输与异步传输的主要区别在于同步传输中，如果调用recvfrom后会一致阻塞运行，从而导致调用线程暂停运行；异步传输机制则不然，会立即返回。

# 网络编程中设计并发服务器，使用多进程与多线程，请问有什么区别？
答案一:
1 进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。
2 线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。两者都可以提高程序的并发度，提高程序运行效率和响应时间。
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
答案二:
根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的：
1 速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。
2 资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。
3 同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内。等等

# Windows编程的知识点，如消息机制，一个自定义消息如何实现。
自定义消息共分为3步骤：
1）自定义消息：#defineWM_MYMSGWM_USER+1
2）在头文件中声明函数：afx_msg void onMyMsg();
3) 在消息映射中添加对应关系：
//BEGIN_MESSAGE_MAP(CDefMsgDemoDlg,CDialog)//END_MESSAGE_MAP()
ON_MESSAGE(WM_MYMSG,onMyMsg)
4）定义函数void onMyMsg();
核心即：函数原型、关联消息与消息响应函数的宏、函数实现。

# SNMP协议
简单网络管理协议——应用层协议.
包括5种数据包：Get-Request;Get-Next-Request;Set-Request, Get-Response; Trap;
RAW套接字 广泛应用于高级网络编程，如SNIFFER、拒绝服务、IP欺骗都是通过原始套接字实现的。

# 窗口创建的步骤：
1）设计窗口类(填充结构体) 2）注册窗口类RegisterClass 3）创建窗口 4）显示ShowWindow&更新窗口UpdateWindow 4）循环获取消息GetMessage（）（（转换）TranslateMessage消息、处理消息DispathMessage（将消息交付给窗口过程进行处理））

# 当触发按钮以后发生了什么？
1）比如点击鼠标左键后，操作系统首先会感知到该事件
2）操作系统将事件其转化为消息
3）操作系统将消息投递到对应程序（线程）的消息队列中
4）应用程序（线程）从消息队列中通过GetMessage获取消息，并通过DispathMessge将消息交付给操作系统
5）操作系统通过设计窗口类时指定的窗口过程对对消息进行处理。

# 你平时是如何调试程序的？（引申）当一个程序在自己机器上运行正常，但是在其他机器上程序运行崩溃，如何查找原因？
断点调试：
值：查看变量（Variables）、表达式、内存（Memory）、寄存器（Register）的值。
进程控制：VC允许被中断的程序继续运行、单步运行和运行到指定光标处，分别对应快捷键F5、F10/F11和CTRL+F10。
其他调试手段：系统提供一系列特殊的函数或者宏来处理Debug版本相关的信息TRACE、ASSERT、VERIFy。Ctrl+B打开断点设置。
运行崩溃，如何查找原因? [提示后]，可以通过打印语句来发现错误！

# 线程、窗口、消息队列三者之间的关系？
MSDN上如是说：
Thethread to which the message is posted musthave created a message queue,or elsethe call to PostThreadMessagefails.  
并提供了如下两种解决方法：
CallPostThreadMessage.If it fails, call theSleep function and call PostThreadMessageagain. Repeat  until PostThreadMessage  succeeds. 
面试官说：一个线程对应一个或多个窗口（创建的关系），同时一个线程对应了一个消息队列。
总结如下：
1.在MFC程序框架里面，CWinThread专门负责线程创建的，它可以创建用户界面线程，及工作者线程。其中用户界面线程是包含消息队列的，而工作者线程是不包含消息队列的。即一句话：用户界面线程对应一个消息队列。
2.CWinThread类和CWnd类都派生自CCmdTarget，而CDialog对话框类、视图类CView都派生自CWnd。
深入浅出MFC里一句话：不是每一个窗口都产生一个线程（因为要付出昂贵的线程切换代价）。即，深入理解之：一个线程可以对应多个窗口。主线程可以创建出其所要的全部窗口。
结论：一个UI线程就1组消息队列集合，一个线程可以创建多个窗口。

# OSI 7层模型是什么? 每层有哪些协议？  
应用层 FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS
表示层 加密，ASCII等 
会话层 RPC，SQL等 
传输层 TCP，UDP，SPX 
网络层 IP协议、ICMP协议、ARP协议、RARP协议  
数据链路层 ATM，FDDI等 
物理层 Rj45，802.3等 

# 请写出下列服务使用的默认端口POP3、SMTP、FTP、MSN、DNS、SQL  
端口：21   服务：FTP  
端口：22   服务：SSH  
端口：23   服务：Telnet  
端口：25   服务：SMTP  
端口：80   服务：HTTP 
端口：110  服务：Post Office Protocol -Version3 (pop3) 
端口:569   服务:Membership MSN  端口1433和1434  服务:SQL 
DNS协议运行在UDP之上,使用端口号53

