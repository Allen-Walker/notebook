//宏函数的特点是内嵌到调用代码中去,避免了函数调用的开销。
//但是由于宏函数的处理发生在预处理阶段,缺失了语法检测和有可能带来的语意差错。

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

using namespace std;

#define MAX(a, b) \
	((a) > (b) ? (a) : (b))

inline int max(int a, int b)
{
	return (a > b) ? a : b;
}

int main(void)
{
	int a = 10;
	int b = 20;
	int c = max(a, b);
	cout << c << endl;
	/*
	//编译器将内联函数的函数体直接展开	
	c = (a > b) ? a : b;
	//由于内联函数的函数体在代码段中会出现多个“副本”,因此会增加代码段的空间。
	//inline函数适用于函数体很“小”,且被“频繁”调用。
	*/

	/*
	1 内联函数声明时inline关键字必须和函数定义结合在一起,否则编译器会直接忽略内联请求
	2 C++编译器直接将函数体插入在函数调用的地方。
	3 内联函数没有普通函数调用时的额外开销(压栈,跳转,返回)。
	4 内联函数是一种特殊的函数,具有普通函数的特征(参数检查,返回类型等)。
	5 内联函数由编译器处理,直接将编译后的函数体插入调用的地方, 宏代码片段由预处理器处理,
		进行简单的文本替换,没有任何编译过程。
	6 C++中内联编译的限制:
			不能存在任何形式的循环语句
			不能存在过多的条件判断语句
			函数体不能过于庞大
			不能对函数进行取址操作
			函数内联声明必须在调用语句之前
	7 编译器对于内联函数的限制并不是绝对的,内联函数相对于普通函数的优
		势只是省去了函数调用时压栈,跳转和返回的开销。因此,当函数体的执行开
		销远大于压栈,跳转和返回所用的开销时,那么内联将无意义。
	*/

	return 0;
}
